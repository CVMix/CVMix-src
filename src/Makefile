.SUFFIXES: .F90 .o

extension = .F90

# Need CVMix root directory
# If using old version of make, pass in CVMIX_ROOT
ifeq ($(wildcard $(MAKEFILE_LIST)),)
  CVMIX_ROOT = ..
else
  ThisMakefile=$(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))
  ifeq (/,$(findstring /,$(ThisMakefile)))
    ThisDir=$(shell x=$(ThisMakefile) && echo $${x%/*})/
  endif
  CVMIX_ROOT = $(realpath $(ThisDir)..)
endif

# Directories needed by Makefile
LIB_DIR = $(CVMIX_ROOT)/lib
INC_DIR = $(CVMIX_ROOT)/include
BLD_DIR = $(CVMIX_ROOT)/bld
OBJ_DIR = $(BLD_DIR)/obj
SRC_DIR = $(CVMIX_ROOT)/src
SRC_DRIVE_DIR = $(SRC_DIR)/drivers
SRC_SHARED_DIR = $(SRC_DIR)/shared

# Name of executable
EXE = $(CVMIX_ROOT)/bin/cvmix

# Need to know which driver to use (should be passed in)
CVMIX_DRIVER = FALSE
ifeq ($(CVMIX_DRIVER),FALSE)
  CVMIX_DRIVER_NOT_SPECIFIED = TRUE
else
  ifeq ($(wildcard $(SRC_DRIVE_DIR)/$(CVMIX_DRIVER)),)
    CVMIX_DRIVER_NOT_FOUND = TRUE
  else
    CVMIX_DRIVER_O = $(CVMIX_DRIVER:$(extension)=.o)
  endif
endif

# File containing information about compiler and netCDF (generated by ./setup)
ENV_FILE = $(BLD_DIR)/.CVMix_env

# File containing information about whether or not the last build linked to
# netCDF (see below for more details)
INFO_FILE = $(BLD_DIR)/.netcdf_info

ifeq ($(wildcard $(ENV_FILE)),)
  NEED_ENV_FILE = TRUE
else
  NEED_ENV_FILE = FALSE
  include $(ENV_FILE)
endif

# update FCFLAGS based on compiler
include $(BLD_DIR)/CompileFlags.mak
LINKING_FLAGS = -L$(LIB_DIR) -lcvmix

# If you build without netCDF and then decide you want to build with netCDF (or
# vice versa), you need to clean the cvmix_output and cvmix_driver object files.
# The way this is handled is by storing whether the last compilation used netCDF
# or not in the hidden file .netcdf_info; whether the current built is using
# netCDF or not is stored in the variable NEW_NETCDF while the contents of
# .netcdf_info is stored in the variable OLD_NETCDF. The target "check" compares
# these two variables and deletes the necessary object and module files  if they
# differ. If the file doesn't exist, the two variables are equal.
ifeq ($(USE_NETCDF),TRUE)
  ifeq ($(FC),xlf90)
    FCFLAGS += -WF,-D_NETCDF
  else
    FCFLAGS += -D_NETCDF
  endif
    FCFLAGS += -I$(NETCDF_INC)
  # Check for netcdf4 library
  ifeq ($(wildcard $(NETCDF_LIB)/libnetcdff.a),)
    LINKING_FLAGS += -L$(NETCDF_LIB) -lnetcdf
  else
    # with netcdf4, need to know whether to include hdf5 or not
    # That comes from $(NETCDF_LIB)/pkgconfig/netcdf.pc
    NETCDF_PC = $(NETCDF_LIB)/pkgconfig/netcdf.pc
    ifeq ($(wildcard $(NETCDF_PC)),)
      LINKING_FLAGS += -L$(NETCDF_LIB) -lnetcdff -lnetcdf
    else
      # get flibs from netcdf.pc
      FLIBS = $(subst flibs=,,$(shell grep flibs $(NETCDF_PC)))
      # Workaround for yellowstone, I need to figure out where this
      # @NC_FLIBS@ comes from
      ifeq ($(FLIBS),@NC_FLIBS@)
        FLIBS = -lnetcdf
      endif
      LINKING_FLAGS += -L$(NETCDF_LIB) $(FLIBS)
    endif
  endif
  NEW_NETCDF = YES
else
  NEW_NETCDF = NO
endif

# Need to include cvmix_kinds_and_types.mod from include (not from bld/obj)
FCFLAGS += -I$(INC_DIR)

ifneq ($(wildcard $(INFO_FILE)),)
  OLD_NETCDF = $(shell cat $(INFO_FILE))
else
  OLD_NETCDF = $(NEW_NETCDF)
endif

ifneq ($(OLD_NETCDF), $(NEW_NETCDF))
  REBUILD = TRUE
endif

# Driver file and its associated object file
F_FILE = $(SRC_DRIVE_DIR)/$(CVMIX_DRIVER)

# Dependencies: all drivers use cvmix_output
OBJS = cvmix_output.o

### TARGETS ###

.PHONY: check lib no_lib exe remove_exe clean libclean distclean

all: exe

# Possible executables: with and without netCDF
netcdf:
	$(MAKE) -f $(SRC_DIR)/Makefile USE_NETCDF=TRUE

$(EXE): $(OBJ_DIR)/$(CVMIX_DRIVER_O)
	$(FC) -o $(EXE) $(OBJ_DIR)/$(CVMIX_DRIVER_O) $(addprefix $(OBJ_DIR)/,$(OBJS)) $(LINKING_FLAGS)

exe: check $(ENV_FILE) lib $(OBJ_DIR)/$(CVMIX_DRIVER_O)
# If NEED_ENV_FILE is TRUE, the check target recursively calls make
# With NEED_ENV_FILE equal to FALSE, so the executable will be built
ifeq ($(NEED_ENV_FILE),FALSE)
	cd $(SRC_DIR); $(MAKE) $(EXE)
	$(shell echo $(NEW_NETCDF) > $(INFO_FILE))
endif

# Create all object and module files
$(OBJ_DIR)/cvmix_output.o: 
	$(FC) $(FCFLAGS) -c $(SRC_DIR)/cvmix_output.F90 -o $@

$(OBJ_DIR)/$(CVMIX_DRIVER_O): $(addprefix $(OBJ_DIR)/,$(OBJS)) \
                              $(F_FILE)
	$(FC) $(FCFLAGS) -c $(F_FILE) -o $@

lib:
	cd $(SRC_SHARED_DIR) ; $(MAKE)

# Utilities:
# 1) check has two tasks --
#    a) sees if we need to rebuild stand-alone components using -D_NETCDF
#    b) make sure a driver was specified
# 2) remove_exe deletes the executable to ensure the proper file is built
# 3) clean deletes object and module files, as well as the netcdf info file
# 4) libclean also removes lib/libcvmix.a include/*.mod so you will need to
#    rebuild the library.
# 5) distclean also removes $ENV_FILE so you will need to re-run setup
check:
# The variables FC, NETCDF_INC, NETCDF_LIB, and NETCDF_LINK are read in from
# CVMix_env. If the file doesn't exist, then the python script "setup" is run
# to generate the file.
	@$(if $(CVMIX_DRIVER_NOT_SPECIFIED), echo "ERROR: You must compile using \
    'make CVMIX_DRIVER=[driver]'. Valid choices are:"; \
    ls -1 $(SRC_DRIVE_DIR); exit 1)
	@$(if $(CVMIX_DRIVER_NOT_FOUND), echo "ERROR: can not find specified \
    driver $(CVMIX_DRIVER). Valid choices are:"; \
    ls -1 $(SRC_DRIVE_DIR); echo "(The .F90 suffix is necessary.)"; exit 1)
	$(if $(REBUILD), rm -f $(OBJ_DIR)/cvmix_output.* $(OBJ_DIR)/$(CVMIX_DRIVER_O))

$(ENV_FILE):
# After building the ENV_FILE, must invoke make again to read it in. Note that
# the cvmix target only builds if NEED_ENV_FILE is FALSE, so after this build
# returns, the cvmix target won't do anything.
	@$(BLD_DIR)/setup $(ENV_FILE)
	$(MAKE) -f $(SRC_DIR)/Makefile

remove_exe:
	/bin/rm -rf $(EXE)

clean: remove_exe
	/bin/rm -rf $(INFO_FILE) $(OBJ_DIR)/*.mod $(OBJ_DIR)/*.o

libclean: clean
	cd $(SRC_SHARED_DIR); $(MAKE) clean 

distclean: libclean
	/bin/rm -rf $(ENV_FILE)
