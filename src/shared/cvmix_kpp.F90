!|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

 module cvmix_kpp

!BOP
!\newpage
! !MODULE: cvmix_kpp
!
! !DESCRIPTION:
!  This module contains routines to initialize the derived types needed for
!  KPP mixing and to set the viscosity and diffusivity coefficients
!  accordingly.
!\\
!\\
!
! !REVISION HISTORY:
!  SVN:$Id$
!  SVN:$URL$

! !USES:

  use cvmix_kinds_and_types, only : cvmix_r8,                &
                                    cvmix_data_type
  use cvmix_put_get, only :         cvmix_put

!EOP

  implicit none
  private
  save

!BOP

! !DEFINED PARAMETERS:
  integer, parameter        :: CVMIX_KPP_INTERP_LINEAR      = 1
  integer, parameter        :: CVMIX_KPP_INTERP_QUAD        = 2
  integer, parameter        :: CVMIX_KPP_INTERP_CUBE_SPLINE = 3
  integer, parameter        :: CVMIX_KPP_MAX_NEWTON_ITERS   = 100
  real(cvmix_r8), parameter :: CVMIX_KPP_NEWTON_TOL         = 1.0e-12_cvmix_r8

! !PUBLIC MEMBER FUNCTIONS:

  public :: cvmix_init_kpp
  ! Note: cvmix_kpp_compute_OBL_depth would be part of cvmix_coeffs_kpp but
  !       CVMix can not smooth the boundary layer depth or correct the
  !       buoyancy flux term
  public :: cvmix_kpp_compute_OBL_depth
  public :: cvmix_coeffs_kpp
  public :: cvmix_put_kpp
  public :: cvmix_get_kpp_real
  ! These are public for testing, may end up private later
  public :: cvmix_kpp_compute_turbulent_scales
  public :: cvmix_kpp_compute_shape_function_coeffs

  interface cvmix_coeffs_kpp
    module procedure cvmix_coeffs_kpp_low
    module procedure cvmix_coeffs_kpp_wrap
  end interface cvmix_coeffs_kpp

  interface cvmix_put_kpp
    module procedure cvmix_put_kpp_int
    module procedure cvmix_put_kpp_real
    module procedure cvmix_put_kpp_logical
  end interface cvmix_put_kpp

  interface cvmix_kpp_compute_OBL_depth
    module procedure cvmix_kpp_compute_OBL_depth_low
    module procedure cvmix_kpp_compute_OBL_depth_wrap
  end interface cvmix_kpp_compute_OBL_depth

! !PUBLIC TYPES:

  ! cvmix_kpp_params_type contains the necessary parameters for KPP mixing
  type, public :: cvmix_kpp_params_type
    private
    real(cvmix_r8) :: Ri_crit      ! Critical Richardson number
                               ! (OBL_depth = point where bulk Ri = Ri_crit)
    real(cvmix_r8) :: vonkarman    ! von Karman constant
    ! For velocity scale function, _m => momentum and _s => scalar (tracer)
    real(cvmix_r8) :: zeta_m       ! parameter for computing vel scale func
    real(cvmix_r8) :: zeta_s       ! parameter for computing vel scale func
    real(cvmix_r8) :: a_m          ! parameter for computing vel scale func
    real(cvmix_r8) :: a_s          ! parameter for computing vel scale func
    real(cvmix_r8) :: c_m          ! parameter for computing vel scale func
    real(cvmix_r8) :: c_s          ! parameter for computing vel scale func
    real(cvmix_r8) :: eps          ! small non-negative val (rec 1e-10)
    integer        :: interp_type  ! type of iterpolation to use
    logical        :: lEkman       ! True => compute Ekman depth limit
    logical        :: lMonOb       ! True => compute Monin-Obukhov limit
  end type cvmix_kpp_params_type

!EOP

type(cvmix_kpp_params_type), target :: CVmix_kpp_params_saved

contains

!BOP

! !IROUTINE: cvmix_init_kpp
! !INTERFACE:

  subroutine cvmix_init_kpp(ri_crit, vonkarman, zeta_m, zeta_s, a_m, a_s,     &
                            c_m, c_s, eps, interp_type, lEkman, lMonOb,       &
                            CVmix_kpp_params_user)

! !DESCRIPTION:
!  Initialization routine for KPP mixing.
!
! !USES:
!  Only those used by entire module.

! !INPUT PARAMETERS:
    real(cvmix_r8),   optional :: ri_crit, vonkarman, zeta_m, zeta_s, a_m, &
                                  a_s, c_m, c_s, eps
    character(len=*), optional :: interp_type
    logical,          optional :: lEkman, lMonOb

! !OUTPUT PARAMETERS:
    type(cvmix_kpp_params_type), intent(inout), target, optional ::           &
                                              CVmix_kpp_params_user

!EOP
!BOC

    type(cvmix_kpp_params_type), pointer :: CVmix_kpp_params_out

    CVmix_kpp_params_out => CVmix_kpp_params_saved
    if (present(CVmix_kpp_params_user)) then
      CVmix_kpp_params_out => CVmix_kpp_params_user
    end if

    if (present(ri_crit)) then
      call cvmix_put_kpp(CVmix_kpp_params_out, 'Ri_crit', ri_crit)
    else
      call cvmix_put_kpp(CVmix_kpp_params_out, 'Ri_crit', 0.3_cvmix_r8)
    end if

    if (present(vonkarman)) then
      call cvmix_put_kpp(CVmix_kpp_params_out, 'vonkarman', vonkarman)
    else
      call cvmix_put_kpp(CVmix_kpp_params_out, 'vonkarman', 0.41_cvmix_r8)
    end if

    if (present(zeta_m)) then
      call cvmix_put_kpp(CVmix_kpp_params_out, 'zeta_m', zeta_m)
    else
      call cvmix_put_kpp(CVmix_kpp_params_out, 'zeta_m', -0.2_cvmix_r8)
    end if

    if (present(zeta_s)) then
      call cvmix_put_kpp(CVmix_kpp_params_out, 'zeta_s', zeta_s)
    else
      call cvmix_put_kpp(CVmix_kpp_params_out, 'zeta_s', -1.0_cvmix_r8)
    end if

    if (present(a_m)) then
      call cvmix_put_kpp(CVmix_kpp_params_out, 'a_m', a_m)
    else
      call cvmix_put_kpp(CVmix_kpp_params_out, 'a_m', 1.26_cvmix_r8)
    end if

    if (present(a_s)) then
      call cvmix_put_kpp(CVmix_kpp_params_out, 'a_s', a_s)
    else
      call cvmix_put_kpp(CVmix_kpp_params_out, 'a_s', -28.86_cvmix_r8)
    end if

    if (present(c_m)) then
      call cvmix_put_kpp(CVmix_kpp_params_out, 'c_m', c_m)
    else
      call cvmix_put_kpp(CVmix_kpp_params_out, 'c_m', 8.38_cvmix_r8)
    end if

    if (present(c_s)) then
      call cvmix_put_kpp(CVmix_kpp_params_out, 'c_s', c_s)
    else
      call cvmix_put_kpp(CVmix_kpp_params_out, 'c_s', 98.96_cvmix_r8)
    end if

    if (present(eps)) then
      call cvmix_put_kpp(CVmix_kpp_params_out, 'eps', eps)
    else
      call cvmix_put_kpp(CVmix_kpp_params_out, 'eps', 1e-10_cvmix_r8)
    end if

    if (present(interp_type)) then
      select case (trim(interp_type))
        case ('line', 'linear')
          call cvmix_put_kpp(CVmix_kpp_params_out, 'interp_type', &
                             CVMIX_KPP_INTERP_LINEAR)
        case ('quad', 'quadratic')
          call cvmix_put_kpp(CVmix_kpp_params_out, 'interp_type', &
                             CVMIX_KPP_INTERP_QUAD)
        case ('cube', 'cubic', 'cubic_spline', 'cubic spline')
          call cvmix_put_kpp(CVmix_kpp_params_out, 'interp_type', &
                             CVMIX_KPP_INTERP_CUBE_SPLINE)
        case DEFAULT
          print*, "ERROR: ", trim(interp_type), " is not a valid type of ", &
                  "interpolation!"
          stop 1
      end select
    else
      call cvmix_put_kpp(CVmix_kpp_params_out, 'interp_type', &
                         CVMIX_KPP_INTERP_QUAD)
    end if

    if (present(lEkman)) then
      call cvmix_put_kpp(CVmix_kpp_params_out, 'lEkman', lEkman)
    else
      call cvmix_put_kpp(CVmix_kpp_params_out, 'lEkman', .False.)
    end if

    if (present(lMonOb)) then
      call cvmix_put_kpp(CVmix_kpp_params_out, 'lMonOb', lMonOb)
    else
      call cvmix_put_kpp(CVmix_kpp_params_out, 'lMonOb', .False.)
    end if

!EOC

  end subroutine cvmix_init_kpp

!BOP

! !IROUTINE: cvmix_coeffs_kpp_wrap
! !INTERFACE:

  subroutine cvmix_coeffs_kpp_wrap(CVmix_vars, CVmix_kpp_params_user)

! !DESCRIPTION:
!  Computes vertical diffusion coefficients for the double diffusion mixing
!  parameterizatiion.
!\\
!\\
!
! !USES:
!  only those used by entire module.

! !INPUT PARAMETERS:
    type(cvmix_kpp_params_type), intent(in), optional, target ::              &
                                           CVmix_kpp_params_user

! !INPUT/OUTPUT PARAMETERS:
    type(cvmix_data_type), intent(inout) :: CVmix_vars

!EOP
!BOC

    call cvmix_coeffs_kpp(CVmix_vars%diff_iface, CVmix_vars%visc_iface,       &
                          CVmix_vars%zw_iface, CVmix_vars%OBL_depth,          &
                          CVmix_VARS%kOBL_depth, CVmix_vars%surf_fric,        &
                          CVmix_vars%surf_buoy,         &
                          CVmix_kpp_params_user)

!EOC

  end subroutine cvmix_coeffs_kpp_wrap

!BOP

! !IROUTINE: cvmix_coeffs_kpp_low
! !INTERFACE:

  subroutine cvmix_coeffs_kpp_low(diff, visc, zw_iface, OBL_depth, kOBL_depth,&
                                  surf_fric, surf_buoy, CVmix_kpp_params_user)

! !DESCRIPTION:
!  Computes vertical diffusion coefficients for the double diffusion mixing
!  parameterizatiion.
!\\
!\\
!
! !USES:
!  only those used by entire module.

! !INPUT PARAMETERS:
    type(cvmix_kpp_params_type), intent(in), optional, target ::              &
                                           CVmix_kpp_params_user
    real(cvmix_r8), dimension(:),   intent(in) :: zw_iface

! !INPUT/OUTPUT PARAMETERS:
    real(cvmix_r8), dimension(:,:), intent(inout) :: diff
    real(cvmix_r8), dimension(:),   intent(inout) :: visc
    real(cvmix_r8),                 intent(in)    :: OBL_depth, surf_fric,    &
                                                     surf_buoy
    integer,                        intent(in)    :: kOBL_depth

!EOP
!BOC

    ! Local variables
    type(cvmix_kpp_params_type), pointer      :: CVmix_kpp_params_in
    real(cvmix_r8), dimension(:), allocatable :: sigma, w_m, w_s
    real(cvmix_r8), dimension(4,3)            :: shape_coeffs
    real(cvmix_r8), dimension(3) :: Gat1, DGat1
    integer :: nlev_p1, kw, i

    CVmix_kpp_params_in => CVmix_kpp_params_saved
    if (present(CVmix_kpp_params_user)) then
      CVmix_kpp_params_in => CVmix_kpp_params_user
    end if

    nlev_p1 = size(visc)
    allocate(sigma(nlev_p1), w_m(nlev_p1), w_s(nlev_p1))
    sigma = zw_iface/OBL_depth

    diff = CVmix_kpp_params_in%Ri_crit
    visc = CVmix_kpp_params_in%Ri_crit

    ! (1) Compute turbulent velocity scales
    call cvmix_kpp_compute_turbulent_scales(sigma, OBL_depth, surf_buoy,      &
                                            surf_fric, w_m, w_s)

    ! (2) Compute G(1) and G'(1) for three cases:
    !     i) temperature diffusivity
    !     ii) other tracers diffusivity
    !     iii) viscosity
    Gat1  = 0.0_cvmix_r8
    DGat1 = 0.0_cvmix_r8

    ! (3) Compute coefficients of shape function
    do i=1,3
      call cvmix_kpp_compute_shape_function_coeffs(Gat1(i), DGat1(i),         &
                                                   shape_coeffs(:,i))
    end do

    ! (4) Compute diffusivities and viscosity in ocean boundary layer
    do kw=1,kOBL_depth
      diff(kw,1) = OBL_depth * w_s(kw) *                                      &
                   cvmix_kpp_evaluate_shape_function(shape_coeffs(:,1),       &
                                                     sigma(kw))
      diff(kw,2) = OBL_depth * w_s(kw) *                                      &
                   cvmix_kpp_evaluate_shape_function(shape_coeffs(:,2),       &
                                                     sigma(kw))
      visc(kw)   = OBL_depth * w_m(kw) *                                      &
                   cvmix_kpp_evaluate_shape_function(shape_coeffs(:,3),       &
                                                     sigma(kw))
    end do

    ! (5) Compute non-local transport term

    ! (6) Compute enhanced mixing

    ! (7) Combine interior and boundary coefficients + non-local term

    ! Clean up memory
    deallocate(sigma, w_m, w_s)

!EOC
  end subroutine cvmix_coeffs_kpp_low

!BOP

! !IROUTINE: cvmix_put_kpp_real
! !INTERFACE:

  subroutine cvmix_put_kpp_real(CVmix_kpp_params, varname, val)

! !DESCRIPTION:
!  Write a real value into a cvmix\_kpp\_params\_type variable.
!\\
!\\

! !USES:
!  Only those used by entire module. 

! !INPUT PARAMETERS:
    character(len=*), intent(in) :: varname
    real(cvmix_r8),   intent(in) :: val

! !OUTPUT PARAMETERS:
    type(cvmix_kpp_params_type), intent(inout) :: CVmix_kpp_params
!EOP
!BOC

    select case (trim(varname))
      case ('Ri_crit')
        CVmix_kpp_params%Ri_crit = val
      case ('vonkarman')
        CVmix_kpp_params%vonkarman = val
      case ('zeta_m')
        CVmix_kpp_params%zeta_m = val
      case ('zeta_s')
        CVmix_kpp_params%zeta_s = val
      case ('a_m')
        CVmix_kpp_params%a_m = val
      case ('a_s')
        CVmix_kpp_params%a_s = val
      case ('c_m')
        CVmix_kpp_params%c_m = val
      case ('c_s')
        CVmix_kpp_params%c_s = val
      case ('eps')
        CVmix_kpp_params%eps = val
      case DEFAULT
        print*, "ERROR: ", trim(varname), " not a valid choice!"
        stop 1
    end select

!EOC

  end subroutine cvmix_put_kpp_real

!BOP

! !IROUTINE: cvmix_put_kpp_int
! !INTERFACE:

  subroutine cvmix_put_kpp_int(CVmix_kpp_params, varname, val)

! !DESCRIPTION:
!  Write an integer value into a cvmix\_kpp\_params\_type variable.
!\\
!\\

! !USES:
!  Only those used by entire module. 

! !INPUT PARAMETERS:
    character(len=*), intent(in) :: varname
    integer,          intent(in) :: val

! !OUTPUT PARAMETERS:
    type(cvmix_kpp_params_type), intent(inout) :: CVmix_kpp_params
!EOP
!BOC

    select case (trim(varname))
      case ('interp_type')
        CVmix_kpp_params%interp_type = val
      case DEFAULT
        call cvmix_put_kpp(CVmix_kpp_params, varname, real(val, cvmix_r8))
    end select

!EOC

  end subroutine cvmix_put_kpp_int

!BOP

! !IROUTINE: cvmix_put_kpp_logical
! !INTERFACE:

  subroutine cvmix_put_kpp_logical(CVmix_kpp_params, varname, val)

! !DESCRIPTION:
!  Write a Boolean value into a cvmix\_kpp\_params\_type variable.
!\\
!\\

! !USES:
!  Only those used by entire module. 

! !INPUT PARAMETERS:
    character(len=*), intent(in) :: varname
    logical,          intent(in) :: val

! !OUTPUT PARAMETERS:
    type(cvmix_kpp_params_type), intent(inout) :: CVmix_kpp_params
!EOP
!BOC

    select case (trim(varname))
      case ('lEkman')
        CVmix_kpp_params%lEkman = val
      case ('lMonOb')
        CVmix_kpp_params%lMonOb = val
      case DEFAULT
        print*, "ERROR: ", trim(varname), " is not a boolean variable!"
        stop 1
    end select

!EOC

  end subroutine cvmix_put_kpp_logical

!BOP

! !IROUTINE: cvmix_get_kpp_real
! !INTERFACE:

  function cvmix_get_kpp_real(varname, CVmix_kpp_params_user)

! !DESCRIPTION:
!  Return the real value of a cvmix\_kpp\_params\_type variable.
!  NOTE: This function is not efficient and is only for infrequent
!  queries of ddiff parameters, such as at initialization.
!\\
!\\

! !USES:
!  Only those used by entire module. 

! !INPUT PARAMETERS:
    character(len=*),                              intent(in) :: varname
    type(cvmix_kpp_params_type), optional, target, intent(in) ::              &
                                           CVmix_kpp_params_user

! !OUTPUT PARAMETERS:
    real(cvmix_r8) :: cvmix_get_kpp_real
!EOP
!BOC

    type(cvmix_kpp_params_type), pointer :: CVmix_kpp_params_in

    CVmix_kpp_params_in => CVmix_kpp_params_saved
    if (present(CVmix_kpp_params_user)) then
      CVmix_kpp_params_in => CVmix_kpp_params_user
    end if

    cvmix_get_kpp_real = 0.0_cvmix_r8
    select case (trim(varname))
      case ('Ri_crit')
        cvmix_get_kpp_real = CVmix_kpp_params_in%Ri_crit
      case ('vonkarman')
        cvmix_get_kpp_real = CVmix_kpp_params_in%vonkarman
      case ('zeta_m')
        cvmix_get_kpp_real = CVmix_kpp_params_in%zeta_m
      case ('zeta_s')
        cvmix_get_kpp_real = CVmix_kpp_params_in%zeta_s
      case ('a_m')
        cvmix_get_kpp_real = CVmix_kpp_params_in%a_m
      case ('a_s')
        cvmix_get_kpp_real = CVmix_kpp_params_in%a_s
      case ('c_m')
        cvmix_get_kpp_real = CVmix_kpp_params_in%c_m
      case ('c_s')
        cvmix_get_kpp_real = CVmix_kpp_params_in%c_s
      case ('eps')
        cvmix_get_kpp_real = CVmix_kpp_params_in%eps
      case DEFAULT
        print*, "ERROR: ", trim(varname), " not a valid choice!"
        stop 1
    end select

!EOC

  end function cvmix_get_kpp_real

!BOP

! !IROUTINE: cvmix_kpp_compute_OBL_depth_low
! !INTERFACE:

  subroutine cvmix_kpp_compute_OBL_depth_low(Ri_bulk, depth, OBL_depth,       &
                                             kOBL_depth, surf_fric, surf_buoy,&
                                             Coriolis, CVmix_kpp_params_user)

! !DESCRIPTION:
!  Computes the depth of the ocean boundary layer (OBL) for a given column
!\\
!\\

! !USES:
!  Only those used by entire module. 

! !INPUT PARAMETERS:
    type(cvmix_kpp_params_type), optional, target, intent(in) ::              &
                                           CVmix_kpp_params_user
    real(cvmix_r8), dimension(:), intent(in) :: Ri_bulk, depth
    real(cvmix_r8),               intent(in) :: surf_fric, surf_buoy, Coriolis

! !OUTPUT PARAMETERS:
    real(cvmix_r8), intent(out) :: OBL_depth
    integer,        intent(out) :: kOBL_depth

!EOP
!BOC

    ! Local variables
    integer :: nlev, kt
    real(kind=cvmix_r8), dimension(4) :: coeffs
    real(kind=cvmix_r8) :: Ekman, MoninObukhov, OBL_Limit
    logical :: lstable

    type(cvmix_kpp_params_type), pointer :: CVmix_kpp_params_in

    CVmix_kpp_params_in => CVmix_kpp_params_saved
    if (present(CVmix_kpp_params_user)) then
      CVmix_kpp_params_in => CVmix_kpp_params_user
    end if

    nlev = size(Ri_bulk)
    if (nlev.ne.size(depth)) then
      print*, "ERROR: Ri_bulk and depth must be same size!"
      stop 1
    end if

    ! if lEkman = .true., OBL_depth must be between the surface and the Ekman
    ! depth. Similarly, if lMonOb = .true., OBL_depth must be between the
    ! surface and the Monin-Obukhov depth
    OBL_limit = depth(nlev)


    ! Since depth gets more negative as you go deeper, that translates into
    ! OBL_depth = max(computed depth, Ekman depth, M-O depth)
    ! (MNL: change this when we make OBL_depth positive-down!)
    if (CVmix_kpp_params_in%lEkman) then
      if (Coriolis.eq.0.0_cvmix_r8) then
        ! Rather than divide by zero, set Ekman depth to ocean bottom
        Ekman = depth(nlev)
      else
        Ekman = 0.7_cvmix_r8*surf_fric/Coriolis
      end if
      OBL_limit = max(OBL_limit, Ekman)
    end if

    if (CVmix_kpp_params_in%lMonOb) then
      ! Column is stable if surf_buoy > 0
      lstable = (surf_buoy.gt.0.0_cvmix_r8)

      if (lstable) then
        MoninObukhov = surf_fric**3/(surf_buoy*cvmix_get_kpp_real('vonkarman',&
                                                     CVmix_kpp_params_in))
      else
        MoninObukhov = depth(nlev)
      end if
      OBL_limit = max(OBL_limit, MoninObukhov)
    end if

    ! Interpolation Step
    ! (1) Find kt such that Ri_bulk at level kt+1 > Ri_crit
    do kt=1,nlev-1
      if (Ri_bulk(kt+1).ge.CVmix_kpp_params_in%ri_crit) &
        exit
    end do
    kOBL_depth = kt
    if (kt.eq.nlev) then
      OBL_depth = depth(nlev)
    else
      if (kt.eq.1) then
        call cvmix_poly_interp(coeffs, CVmix_kpp_params_in%interp_type,       &
                               depth(kt:kt+1), Ri_bulk(kt:kt+1))
      else
        call cvmix_poly_interp(coeffs, CVmix_kpp_params_in%interp_type,       &
                               depth(kt:kt+1), Ri_bulk(kt:kt+1), depth(kt-1), &
                               Ri_bulk(kt-1))
      end if
      coeffs(4) = coeffs(4)-CVmix_kpp_params_in%ri_crit

      OBL_depth = cubic_root_find(coeffs, 0.5_cvmix_r8*(depth(kt)+depth(kt+1)))
    end if

    ! Note: maybe there are times when we don't need to do the interpolation
    !       because we know OBL_depth will equal OBL_limit?
    OBL_depth = max(OBL_depth, OBL_limit)

!EOC

  end subroutine cvmix_kpp_compute_OBL_depth_low

!BOP

! !IROUTINE: cvmix_kpp_compute_OBL_depth_wrap
! !INTERFACE:

  subroutine cvmix_kpp_compute_OBL_depth_wrap(CVmix_vars, CVmix_kpp_params_user)

! !DESCRIPTION:
!  Computes the depth of the ocean boundary layer (OBL) for a given column
!\\
!\\

! !USES:
!  Only those used by entire module. 

! !INPUT PARAMETERS:
    type(cvmix_kpp_params_type), optional, target, intent(in) ::                &
                                           CVmix_kpp_params_user

! !OUTPUT PARAMETERS:
    type(cvmix_data_type), intent(inout) :: CVmix_vars

!EOP
!BOC

    ! Local variables
    real(cvmix_r8) :: lcl_obl_depth
    integer        :: lcl_kobl_depth

    call cvmix_kpp_compute_OBL_depth(CVmix_vars%Rib, CVmix_vars%zt,           &
                                     lcl_obl_depth,  lcl_kobl_depth,          &
                                     CVmix_vars%surf_fric,                    &
                                     CVmix_vars%surf_buoy,                    & 
                                     CVmix_vars%Coriolis,                     &
                                     CVmix_kpp_params_user)
    call cvmix_put(CVmix_vars, 'OBL_depth', lcl_obl_depth)
    call cvmix_put(CVmix_vars, 'kOBL_depth', lcl_kobl_depth)

!EOC

  end subroutine cvmix_kpp_compute_OBL_depth_wrap

!BOP

! !IROUTINE: cvmix_kpp_compute_turbulent_scales
! !INTERFACE:

  subroutine cvmix_kpp_compute_turbulent_scales(sigma_coord, OBL_depth,       &
                                                surf_buoy_force,              &
                                                surf_fric_vel, w_m, w_s,      &
                                                CVmix_kpp_params_user)

! !DESCRIPTION:
!  Computes the turbulent velocity scales for momentum ($w\_m$) and scalars
!  ($w\_s$)
!\\
!\\

! !USES:
!  Only those used by entire module. 

! !INPUT PARAMETERS:
    real(cvmix_r8), dimension(:), intent(in) :: sigma_coord
    real(cvmix_r8), intent(in) :: OBL_depth, surf_buoy_force, surf_fric_vel
    type(cvmix_kpp_params_type), intent(in), optional, target ::              &
                                           CVmix_kpp_params_user

! !OUTPUT PARAMETERS:
    real(cvmix_r8), optional, dimension(:), intent(inout) :: w_m
    real(cvmix_r8), optional, dimension(:), intent(inout) :: w_s

!EOP
!BOC

    ! Local variables
    integer :: nlev_p1, kw
    logical :: compute_wm, compute_ws
    real(cvmix_r8), allocatable, dimension(:) :: zeta, zeta_h
    real(cvmix_r8) :: vonkar
    type(cvmix_kpp_params_type), pointer :: CVmix_kpp_params_in

    nlev_p1 = size(sigma_coord)
    allocate(zeta(nlev_p1), zeta_h(nlev_p1))

    CVmix_kpp_params_in => CVmix_kpp_params_saved
    if (present(CVmix_kpp_params_user)) then
      CVmix_kpp_params_in => CVmix_kpp_params_user
    end if

    compute_wm = present(w_m)
    compute_ws = present(w_s)
    vonkar = cvmix_get_kpp_real('vonkarman', CVmix_kpp_params_in)

    zeta_h = sigma_coord*OBL_depth*surf_buoy_force*vonkar

    zeta = zeta_h/(surf_fric_vel**3 +                                         &
           cvmix_get_kpp_real('eps', CVmix_kpp_params_in))

    if (compute_wm) then
      if (size(w_m).ne.nlev_p1) then
        print*, "ERROR: sigma_coord and w_m must be same size!"
        deallocate(zeta, zeta_h)
        stop 1
      end if
      do kw=1,nlev_p1
        if (zeta(kw).ge.0) then
          ! Stable region
          w_m(kw) = vonkar*surf_fric_vel/(real(1,cvmix_r8) + real(5,cvmix_r8)*&
                    zeta(kw))
        else if (zeta(kw).ge.                                                 &
                 cvmix_get_kpp_real('zeta_m', CVmix_kpp_params_in)) then
          w_m(kw) = vonkar*surf_fric_vel*                                     &
                (real(1,cvmix_r8) - real(16,cvmix_r8)*zeta(kw))**0.25_cvmix_r8
        else
          w_m(kw) = vonkar*(cvmix_get_kpp_real('a_m', CVmix_kpp_params_in)*   &
            (surf_fric_vel**3)-cvmix_get_kpp_real('c_m', CVmix_kpp_params_in)*&
            zeta_h(kw))**(real(1,cvmix_r8)/real(3,cvmix_r8))
        end if
      end do
    end if

    if (compute_ws) then
      if (size(w_s).ne.nlev_p1) then
        print*, "ERROR: sigma_coord and w_s must be same size!"
        deallocate(zeta, zeta_h)
        stop 1
      end if
      do kw=1,nlev_p1
        if (zeta(kw).ge.0) then
          ! Stable region
          w_s(kw) = vonkar*surf_fric_vel/(real(1,cvmix_r8) + real(5,cvmix_r8)*&
                    zeta(kw))
        else if (zeta(kw).ge.                                                 &
                 cvmix_get_kpp_real('zeta_s', CVmix_kpp_params_in)) then
          w_s(kw) = vonkar*surf_fric_vel*                                         &
                sqrt(real(1,cvmix_r8) - real(16,cvmix_r8)*zeta(kw))
        else
          w_s(kw) = vonkar*(cvmix_get_kpp_real('a_s', CVmix_kpp_params_in)*       &
            (surf_fric_vel**3)-cvmix_get_kpp_real('c_s', CVmix_kpp_params_in)*&
            zeta_h(kw))**(real(1,cvmix_r8)/real(3,cvmix_r8))
        end if
      end do
    end if

    deallocate(zeta, zeta_h)

!EOC

  end subroutine cvmix_kpp_compute_turbulent_scales

!BOP

! !IROUTINE: cvmix_kpp_compute_shape_function_coeffs
! !INTERFACE:

  subroutine cvmix_kpp_compute_shape_function_coeffs(GAT1, DGAT1, coeffs)

! !DESCRIPTION:
!  Computes the coefficients of the shape function $G(\sigma) = a_0 + a_1\sigma
!  + a_2\sigma^2 + a_3\sigma^3$, where
!  \begin{eqnarray*}
!    a_0 & = & 0 \\
!    a_1 & = & 1 \\
!    a_2 & = &  3G(1) - G'(1) - 2 \\
!    a_3 & = & -2G(1) + G'(1) + 1
!  \end{eqnarray*}
!  Note that $G(1)$ and $G'(1)$ come from Eq. (18) in Large, et al., and
!  this routine returns coeffs(1:4) = $(/a_0, a_1, a_2, a_3/)$
!\\
!\\

! !USES:
!  Only those used by entire module. 

! !INPUT PARAMETERS:
    real(cvmix_r8), intent(in) :: GAT1  ! G(1)
    real(cvmix_r8), intent(in) :: DGAT1 ! G'(1)

! !OUTPUT PARAMETERS:
    real(cvmix_r8), dimension(4), intent(out) :: coeffs

!EOP
!BOC

    coeffs(1) =  0.0_cvmix_r8
    coeffs(2) =  1.0_cvmix_r8
    coeffs(3) =  3.0_cvmix_r8*GAT1 - DGAT1 - 2.0_cvmix_r8
    coeffs(4) = -2.0_cvmix_r8*GAT1 + DGAT1 + 1.0_cvmix_r8

!EOC

  end subroutine cvmix_kpp_compute_shape_function_coeffs

!BOP

! !IROUTINE: cvmix_kpp_evaluate_shape_function
! !INTERFACE:

  function cvmix_kpp_evaluate_shape_function(coeffs, sigma)

! !DESCRIPTION:
!  Computes the shape function $G(\sigma) = a_0 + a_1\sigma + a_2\sigma^2
!  + a_3\sigma^3$ for given $\sigma$ and $a_i$
!\\
!\\

! !USES:
!  Only those used by entire module. 

! !INPUT PARAMETERS:
    real(cvmix_r8), dimension(4), intent(in) :: coeffs
    real(cvmix_r8),               intent(in) :: sigma

! !OUTPUT PARAMETERS:
    real(cvmix_r8) :: cvmix_kpp_evaluate_shape_function

!EOP
!BOC

    ! Local Variables
    integer :: i

    cvmix_kpp_evaluate_shape_function = 0.0_cvmix_r8
    do i=1,4
      cvmix_kpp_evaluate_shape_function = cvmix_kpp_evaluate_shape_function + &
                                          coeffs(i)*(sigma**(4-1))
    end do

  end function cvmix_kpp_evaluate_shape_function

!BOP

! !IROUTINE: cvmix_poly_interp
! !INTERFACE:

  subroutine cvmix_poly_interp(coeffs, interp_type, x, y, x0, y0)

! !INPUT PARAMETERS:
    integer,                      intent(in)    :: interp_type
    real(cvmix_r8), dimension(2), intent(in)    :: x, y
    real(cvmix_r8), optional,     intent(in)    :: x0, y0
! !OUTPUT PARAMETERS:
    real(cvmix_r8), dimension(4), intent(inout) :: coeffs

!EOP
!BOC

    ! Local variables
    real(cvmix_r8) :: det
    integer        :: k, k2
    real(kind=cvmix_r8), dimension(:,:), allocatable :: Minv
    real(kind=cvmix_r8), dimension(:),   allocatable :: rhs

    ! All interpolation assumes form of
    ! y = ax^3 + bx^2 + cx + d
    ! linear => a = b = 0
    ! quad   => a = 0
    coeffs(1:4) = 0.0_cvmix_r8
    select case (interp_type)
      case (CVMIX_KPP_INTERP_LINEAR)
        ! Match y(1) and y(2)
!        print*, "Linear interpolation"
        coeffs(3) = (y(2)-y(1))/(x(2)-x(1))
        coeffs(4) = y(1)-coeffs(3)*x(1)
      case (CVMIX_KPP_INTERP_QUAD)
        ! Match y(1), y(2), and y'(1) [requires x(0)]
!        print*, "Quadratic interpolation"
        ! [ x2^2 x2 1 ][ b ]   [    y2 ]
        ! [ x1^2 x1 1 ][ c ] = [    y1 ]
        ! [  2x1  1 0 ][ d ]   [ slope ]
        !      ^^^
        !       M
        det = -((x(2)-x(1))**2)
        allocate(Minv(3,3))
        allocate(rhs(3))
        rhs(1) = y(2)
        rhs(2) = y(1)
        if (present(x0).and.present(y0)) then
          rhs(3) = (y(1)-y0)/(x(1)-x0)
        else
          rhs(3) = 0.0_cvmix_r8
        end if

        Minv(1,1) = -real(1, cvmix_r8)/det
        Minv(1,2) = real(1, cvmix_r8)/det
        Minv(1,3) = -real(1, cvmix_r8)/(x(2)-x(1))
        Minv(2,1) = real(2, cvmix_r8)*x(1)/det
        Minv(2,2) = -real(2, cvmix_r8)*x(1)/det
        Minv(2,3) = (x(2)+x(1))/(x(2)-x(1))
        Minv(3,1) = -(x(1)**2)/det
        Minv(3,2) = x(2)*(real(2, cvmix_r8)*x(1)-x(2))/det
        Minv(3,3) = -x(2)*x(1)/(x(2)-x(1))

        do k=1,3
          coeffs(2) = coeffs(2)+Minv(1,k)*rhs(k)
          coeffs(3) = coeffs(3)+Minv(2,k)*rhs(k)
          coeffs(4) = coeffs(4)+Minv(3,k)*rhs(k)
        end do
        deallocate(rhs)
        deallocate(Minv)
      case (CVMIX_KPP_INTERP_CUBE_SPLINE)
        ! Match y(1), y(2), y'(1), and y'(2)
!        print*, "Cubic spline interpolation"
        ! [ x2^3 x2^2 x2 1 ][ a ]   [     y2 ]
        ! [ x1^3 x1^2 x1 1 ][ b ] = [     y1 ]
        ! [  3x1  2x1  1 0 ][ c ]   [ slope1 ]
        ! [  3x2  2x2  1 0 ][ d ]   [ slope2 ]
        !      ^^^
        !       M
        det = -((x(2)-x(1))**3)
        allocate(Minv(4,4))
        allocate(rhs(4))
        rhs(1) = y(2)
        rhs(2) = y(1)
        if (present(x0).and.present(y0)) then
          rhs(3) = (y(1)-y0)/(x(1)-x0)
        else
          rhs(3) = 0.0_cvmix_r8
        end if
        rhs(4) = (y(2)-y(1))/(x(2)-x(1))

        Minv(1,1) = real(2, cvmix_r8)/det
        Minv(1,2) = -real(2, cvmix_r8)/det
        Minv(1,3) = (x(1)-x(2))/det
        Minv(1,4) = (x(1)-x(2))/det
        Minv(2,1) = -real(3, cvmix_r8)*(x(2)+x(1))/det
        Minv(2,2) = real(3, cvmix_r8)*(x(2)+x(1))/det
        Minv(2,3) = (x(2)-x(1))*(real(2, cvmix_r8)*x(2)+x(1))/det
        Minv(2,4) = (x(2)-x(1))*(real(2, cvmix_r8)*x(1)+x(2))/det
        Minv(3,1) = real(6, cvmix_r8)*x(2)*x(1)/det
        Minv(3,2) = -real(6, cvmix_r8)*x(2)*x(1)/det
        Minv(3,3) = -x(2)*(x(2)-x(1))*(real(2, cvmix_r8)*x(1)+x(2))/det
        Minv(3,4) = -x(1)*(x(2)-x(1))*(real(2, cvmix_r8)*x(2)+x(1))/det
        Minv(4,1) = -(x(1)**2)*(real(3, cvmix_r8)*x(2)-x(1))/det
        Minv(4,2) = -(x(2)**2)*(-real(3, cvmix_r8)*x(1)+x(2))/det
        Minv(4,3) = x(1)*(x(2)**2)*(x(2)-x(1))/det
        Minv(4,4) = x(2)*(x(1)**2)*(x(2)-x(1))/det

        do k=1,4
          do k2=1,4
            coeffs(k2) = coeffs(k2)+Minv(k2,k)*rhs(k)
          end do
        end do
        deallocate(rhs)
        deallocate(Minv)
    end select

!EOC

  end subroutine cvmix_poly_interp

  function cubic_root_find(coeffs, x0)

    real(cvmix_r8), dimension(4), intent(in) :: coeffs
    real(cvmix_r8),               intent(in) :: x0

    real(cvmix_r8) :: cubic_root_find
    real(cvmix_r8) :: fun_val, root, slope
    integer :: it_cnt

    root = x0
    fun_val = coeffs(1)*(root**3)+coeffs(2)*(root**2)+coeffs(3)*root+coeffs(4)
    do it_cnt = 1, CVMIX_KPP_MAX_NEWTON_ITERS
      if (abs(fun_val).lt.CVMIX_KPP_NEWTON_TOL) &
        exit
      slope = 3.0_cvmix_r8*coeffs(1)*(root**2)+2.0_cvmix_r8*coeffs(2)*root+coeffs(3)
      root = root - fun_val/slope
      fun_val = coeffs(1)*(root**3)+coeffs(2)*(root**2)+coeffs(3)*root+coeffs(4)
    end do
    cubic_root_find = root

  end function cubic_root_find
      
end module cvmix_kpp
