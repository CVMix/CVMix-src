.SUFFIXES: .F90 .o

extension = .F90

# Need CVMix root directory
# If using old version of make, pass in VMIX_ROOT
ifeq ($(wildcard $(MAKEFILE_LIST)),)
  VMIX_ROOT = ..
else
  ThisMakefile=$(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))
  ifeq (/,$(findstring /,$(ThisMakefile)))
    ThisDir=$(shell x=$(ThisMakefile) && echo $${x%/*})/
  endif
  VMIX_ROOT = $(realpath $(ThisDir)..)
endif

# Directory to build in
BLD = $(VMIX_ROOT)/bld
OBJ = $(BLD)/obj
# Name of executable
EXE = $(BLD)/exe/cvmix
# Directories with source code
SRC = $(VMIX_ROOT)/src
SRC_SHARE = $(SRC)/shared
SRC_DRIVE = $(SRC)/drivers

# Need to know which driver to use (should be passed in)
VMIX_DRIVER = FALSE
ifeq ($(VMIX_DRIVER),FALSE)
  VMIX_DRIVER_NOT_SPECIFIED = TRUE
else
  ifeq ($(wildcard $(SRC_DRIVE)/$(VMIX_DRIVER)),)
    VMIX_DRIVER_NOT_FOUND = TRUE
  else
    VMIX_DRIVER_O = $(VMIX_DRIVER:$(extension)=.o)
  endif
endif

# File containing information about compiler and netCDF (generated by ./setup)
ENV_FILE = $(BLD)/.CVMix_env
# File containing information about whether or not the last build linked to
# netCDF (see below for more details)
INFO_FILE = $(BLD)/.netcdf_info

ifeq ($(wildcard $(ENV_FILE)),)
  NEED_ENV_FILE = TRUE
else
  NEED_ENV_FILE = FALSE
  include $(ENV_FILE)
endif

ifeq ($(FC),gfortran)
  COMPILE_FLAGS = -cpp -O2 -J $(OBJ)
endif

ifeq ($(FC),pgf90)
  COMPILE_FLAGS = -O2 -module $(OBJ)
endif

ifeq ($(FC),ifort)
  COMPILE_FLAGS = -cpp -O2 -module $(OBJ)
endif
LINKING_FLAGS =

# If you build without netCDF and then decide you want to build with netCDF (or
# vice versa), you need to clean the old object files. The way this is handled
# is by storing whether the last compilation used netCDF or not in the hidden
# file .netcdf_info; whether the current built is using netCDF or not is stored
# in the variable NEW_NETCDF while the contents of .netcdf_info is stored in the
# variable OLD_NETCDF. The target "check" compares these two variables and runs
# make clean if they differ. If the file doesn't exist, the two variables are
# equal.
ifeq ($(USE_NETCDF),TRUE)
  ifeq ($(FC),xlf90)
    COMPILE_FLAGS += -WF,-D_NETCDF
  else
    COMPILE_FLAGS += -D_NETCDF
  endif
    COMPILE_FLAGS += -I$(NETCDF_INC)
  LINKING_FLAGS += -L$(NETCDF_LIB) -lnetcdf
  # Check for netcdf4 library
  ifneq ($(wildcard $(NETCDF_LIB)/libnetcdff.a),)
    LINKING_FLAGS += -lnetcdff
  endif
  NEW_NETCDF = YES
else
  NEW_NETCDF = NO
endif

ifneq ($(wildcard $(INFO_FILE)),)
  OLD_NETCDF = $(shell cat $(INFO_FILE))
else
  OLD_NETCDF = $(NEW_NETCDF)
endif

ifneq ($(OLD_NETCDF), $(NEW_NETCDF))
  REBUILD = TRUE
endif

# ORDER MATTERS UNTIL I SET UP DEPENDENCIES
# Also, directories will change once we get a new repository
F_FILES = $(SRC_SHARE)/vmix_kinds_and_types.F90 \
          $(SRC_SHARE)/vmix_put_get.F90         \
          $(SRC_SHARE)/vmix_background.F90      \
          $(SRC_SHARE)/vmix_convection.F90      \
          $(SRC_SHARE)/vmix_shear.F90           \
          $(SRC)/vmix_output.F90                \
          $(SRC_DRIVE)/$(VMIX_DRIVER)

O_FILES = $(subst shared/,,$(subst drivers/,,$(subst $(SRC),$(OBJ),$(F_FILES:$(extension)=.o))))

### TARGETS ###

.PHONY: check

all: $(EXE)

# Possible executables: with and without netCDF
netcdf:
	$(MAKE) -f $(BLD)/Makefile USE_NETCDF=TRUE

$(EXE): remove_exe check $(O_FILES)
# If NEED_ENV_FILE is TRUE, the check target recursively calls make
# With NEED_ENV_FILE equal to FALSE, so the executable will be built
ifeq ($(NEED_ENV_FILE),FALSE)
	$(FC) -o $(EXE) $(O_FILES) $(LINKING_FLAGS)
	$(shell echo $(NEW_NETCDF) > $(INFO_FILE))
endif

# .o files -- until I can handle dependencies automatically, have to be specific
$(OBJ)/vmix_kinds_and_types.o: $(SRC_SHARE)/vmix_kinds_and_types.F90
	$(FC) $(COMPILE_FLAGS) -c $< -o $@

$(OBJ)/vmix_put_get.o: $(SRC_SHARE)/vmix_put_get.F90                       \
                       $(SRC_SHARE)/vmix_kinds_and_types.F90
	$(FC) $(COMPILE_FLAGS) -c $< -o $@

$(OBJ)/vmix_background.o: $(SRC_SHARE)/vmix_background.F90                 \
                          $(SRC_SHARE)/vmix_put_get.F90                    \
                          $(SRC_SHARE)/vmix_kinds_and_types.F90
	$(FC) $(COMPILE_FLAGS) -c $< -o $@

$(OBJ)/vmix_convection.o: $(SRC_SHARE)/vmix_convection.F90                 \
                          $(SRC_SHARE)/vmix_kinds_and_types.F90
	$(FC) $(COMPILE_FLAGS) -c $< -o $@

$(OBJ)/vmix_shear.o: $(SRC_SHARE)/vmix_shear.F90                           \
                     $(SRC_SHARE)/vmix_kinds_and_types.F90
	$(FC) $(COMPILE_FLAGS) -c $< -o $@

$(OBJ)/vmix_output.o: $(SRC)/vmix_output.F90                               \
                      $(SRC_SHARE)/vmix_kinds_and_types.F90
	$(FC) $(COMPILE_FLAGS) -c $< -o $@

$(OBJ)/vmix_BL_driver-mem_copy.o: $(SRC_DRIVE)/vmix_BL_driver-mem_copy.F90 \
                                  $(SRC_SHARE)/vmix_kinds_and_types.F90    \
                                  $(SRC_SHARE)/vmix_background.F90         \
                                  $(SRC_SHARE)/vmix_convection.F90         \
                                  $(SRC_SHARE)/vmix_put_get.F90            \
                                  $(SRC)/vmix_output.F90
	$(FC) $(COMPILE_FLAGS) -c $< -o $@

$(OBJ)/vmix_BL_driver-pointers.o: $(SRC_DRIVE)/vmix_BL_driver-pointers.F90 \
                                  $(SRC_SHARE)/vmix_kinds_and_types.F90    \
                                  $(SRC_SHARE)/vmix_background.F90         \
                                  $(SRC_SHARE)/vmix_convection.F90         \
                                  $(SRC_SHARE)/vmix_put_get.F90            \
                                  $(SRC)/vmix_output.F90
	$(FC) $(COMPILE_FLAGS) -c $< -o $@

$(OBJ)/vmix_KPP-shear_driver.o: $(SRC_DRIVE)/vmix_KPP-shear_driver.F90 \
                                $(SRC_SHARE)/vmix_kinds_and_types.F90  \
                                $(SRC_SHARE)/vmix_shear.F90            \
                                $(SRC_SHARE)/vmix_put_get.F90          \
                                $(SRC)/vmix_output.F90
	$(FC) $(COMPILE_FLAGS) -c $< -o $@

# Utilities:
# 1) check has two tasks --
#    a) sees if we need to rebuild stand-alone components using -D_NETCDF
#    b) make sure a driver was specified
# 2) remove_exe deletes the executable to ensure the proper file is built
# 3) clean deletes object and module files, as well as the netcdf info file
# 4) distclean removes $ENV_FILE so you will need to re-run setup
check: $(ENV_FILE)
# The variables FC, NETCDF_INC, NETCDF_LIB, and NETCDF_LINK are read in from
# CVMix_env. If the file doesn't exist, then the python script "setup" is run
# to generate the file.
	@$(if $(VMIX_DRIVER_NOT_SPECIFIED), echo "ERROR: You must compile using \
    'make VMIX_DRIVER=[driver]'. Valid choices are:"; \
    ls -1 $(SRC_DRIVE); exit 1)
	@$(if $(VMIX_DRIVER_NOT_FOUND), echo "ERROR: can not find specified \
    driver $(VMIX_DRIVER). Valid choices are:"; \
    ls -1 $(SRC_DRIVE); echo "(The .F90 suffix is necessary.)"; exit 1)
	$(if $(REBUILD), rm -f $(OBJ)/vmix_output.o $(OBJ)/$(VMIX_DRIVER_O))

$(ENV_FILE):
# After building the ENV_FILE, must invoke make again to read it in. Note that
# the vmix target only builds if NEED_ENV_FILE is FALSE, so after this build
# returns, the vmix target won't do anything.
	@$(BLD)/setup $(ENV_FILE)
	$(MAKE) -f $(BLD)/Makefile

remove_exe:
	/bin/rm -rf $(EXE)

clean: remove_exe
	/bin/rm -rf $(INFO_FILE) $(OBJ)/*.mod $(OBJ)/*.o

distclean: clean
	/bin/rm -rf $(ENV_FILE)
